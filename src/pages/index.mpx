<template>
  <view class="container" style="{{backgroundStyle}}">
    <view class="content-wrapper">
      <view class="text-card">
        <view class="card-corner-tab">{{characterName}}</view>
        <text class="card-text">{{greetingText}}</text>
      </view>
      <view class="button-group">
        <button class="btn secondary-button">哄睡</button>
        <button class="btn main-button" bindtap="navigateToChat">聊天</button>
        <button class="btn secondary-button">陪我一起</button>
      </view>
    </view>

    <!-- New Side Navigation -->
    <view class="side-nav">
      <view class="side-nav-item" bindtap="navigateToCharacterSelect">
        <text class="side-nav-text">换角色</text>
      </view>
      <view class="side-nav-item" bindtap="navigateToConversations">
        <text class="side-nav-text">消息</text>
      </view>
      <view class="side-nav-item" bindtap="navigateToCreateCharacters">
        <text class="side-nav-text">创建角色</text>
      </view>
    </view>
  </view>
</template>

<script lang="ts">
import { createPage } from '@mpxjs/core'
import { getGreeting } from '../common/greetings'
import { conversationApi, characterApi } from '../common/api'

const GREETING_CACHE_KEY = 'greeting_cache'
const GREETING_CACHE_DURATION_MS = 3 * 60 * 60 * 1000 // 3 hours
const CONVERSATION_CACHE_KEY = 'last_conversation_id'
const HOME_CHARACTER_CACHE_KEY = 'home_character' // 首页固定角色缓存
const LAST_CONVERSATION_CHARACTER_KEY = 'last_conversation_character'
const GREETING_COMMAND = '[GET_GREETING]'

createPage({
  data: {
    greetingText: '', // 问候语
    characterName: '', // 角色名称
    characterId: null as number | null, // 角色 ID
    conversationId: null as number | null, // 缓存的对话 ID
    backgroundStyle: '' // 背景样式
  },

  // 用于取消预取任务的标记
  _isUnloaded: false,

  onLoad() {
    this._isUnloaded = false
  },

  async onShow() {
    // 每次显示页面时加载角色信息
    await this.loadHomeCharacter()
  },

  onUnload() {
    // 标记页面已卸载，防止异步回调继续执行
    this._isUnloaded = true
  },

  methods: {
    /**
     * @description 加载固定到首页的角色信息
     * 1. 先从缓存读取，立即显示（快速响应）
     * 2. 调用接口获取最新数据
     * 3. 如果接口返回数据，更新缓存和 UI，并显示问候语
     * 4. 如果本地无缓存且接口返回 null，跳转到角色列表
     */
    async loadHomeCharacter() {
      // 1. 先从缓存读取，立即显示
      let hasCache = false
      try {
        const cached = wx.getStorageSync(HOME_CHARACTER_CACHE_KEY)
        if (cached && cached.character) {
          this.characterName = cached.character.name || ''
          this.characterId = cached.characterId || null
          this.conversationId = cached.conversationId || null
          hasCache = true
          // 设置背景图片
          this.updateBackground(cached.character.chatBackgroundUrl)
          // 有缓存时立即显示问候语
          this.updateAndDisplayGreeting()
        }
      } catch (e) {
        // 忽略错误
      }

      // 2. 后台调用接口获取最新数据
      await this.syncHomeCharacterFromServer(hasCache)
    },

    /**
     * @description 从服务器同步首页角色数据
     * @param hasCache 是否有本地缓存
     */
    async syncHomeCharacterFromServer(hasCache: boolean) {
      try {
        // 确保登录完成后再请求
        const store = require('../common/store').default
        if (!store.state.token) {
          console.log('[Home] 等待登录完成...')
          await store.dispatch('login')
        }

        const serverData = await characterApi.getPinnedCharacter()

        // 页面已卸载时不执行
        if (this._isUnloaded) return

        if (serverData) {
          // 3. 接口返回数据，更新缓存和 UI
          this.characterName = serverData.name
          this.characterId = serverData.characterId
          this.conversationId = serverData.conversationId

          // 更新背景图片（使用接口返回的数据，如果没有则为 null）
          this.updateBackground((serverData as any).chatBackgroundUrl || null)

          // 更新缓存
          const cacheData = {
            characterId: serverData.characterId,
            conversationId: serverData.conversationId,
            character: {
              id: serverData.characterId,
              name: serverData.name,
              avatarUrl: serverData.avatarUrl,
              description: serverData.description,
              chatBackgroundUrl: (serverData as any).chatBackgroundUrl || null,
              companionBackgroundUrl: (serverData as any).companionBackgroundUrl || null,
              sleepBackgroundUrl: (serverData as any).sleepBackgroundUrl || null
            },
            timestamp: Date.now()
          }
          wx.setStorageSync(HOME_CHARACTER_CACHE_KEY, cacheData)

          // 显示问候语
          this.updateAndDisplayGreeting()
        } else {
          // 4. 接口返回 null，尝试用最近一次聊天角色自动固定到首页
          const lastConversation = this.getLastConversationCache()
          if (lastConversation && lastConversation.character && lastConversation.character.id) {
            this.applyHomeCharacterFromCache(lastConversation)
            try {
              await characterApi.togglePinToHome(lastConversation.character.id)
            } catch (e) {
              console.warn('[Home] 自动固定角色失败:', e)
            }
            return
          }

          // 无最近聊天缓存时，清空缓存并跳转到角色列表
          wx.removeStorageSync(HOME_CHARACTER_CACHE_KEY)
          if (!hasCache) {
            wx.redirectTo({
              url: '/pages/character-select?from=home&tip=pin'
            })
          }
        }
      } catch (e) {
        // 接口调用失败
        console.warn('[Home] 同步首页角色失败:', e)

        // 如果本地无缓存且接口失败，跳转到角色列表
        if (!hasCache) {
          wx.redirectTo({
            url: '/pages/character-select?from=home&tip=pin'
          })
        }
      }
    },

    getLastConversationCache() {
      try {
        return wx.getStorageSync(LAST_CONVERSATION_CHARACTER_KEY) || null
      } catch (e) {
        return null
      }
    },

    applyHomeCharacterFromCache(cached: any) {
      const character = cached.character || {}
      this.characterName = character.name || ''
      this.characterId = character.id || null
      this.conversationId = cached.conversationId || null

      this.updateBackground(character.chatBackgroundUrl || null)

      const cacheData = {
        characterId: character.id || null,
        conversationId: cached.conversationId || null,
        character: {
          id: character.id,
          name: character.name,
          avatarUrl: character.avatarUrl,
          description: character.description,
          chatBackgroundUrl: character.chatBackgroundUrl || null,
          companionBackgroundUrl: character.companionBackgroundUrl || null,
          sleepBackgroundUrl: character.sleepBackgroundUrl || null
        },
        timestamp: Date.now()
      }
      wx.setStorageSync(HOME_CHARACTER_CACHE_KEY, cacheData)
      this.updateAndDisplayGreeting()
    },

    /**
     * @description 更新并显示问候语
     * 1. 优先从缓存读取，若有效且未使用过，则显示并标记为已使用
     * 2. 否则从静态库随机读取
     * 3. 触发后台预取新文案
     */
    updateAndDisplayGreeting() {
      try {
        const cached = wx.getStorageSync(GREETING_CACHE_KEY)
        const now = Date.now()

        // 检查缓存是否存在、未过期、且未使用过
        if (cached && !cached.used && now - cached.timestamp < GREETING_CACHE_DURATION_MS) {
          this.greetingText = cached.text

          // 标记为已使用
          cached.used = true
          wx.setStorageSync(GREETING_CACHE_KEY, cached)
        } else {
          // 缓存无效或已使用，从静态库随机取一个
          this.greetingText = getGreeting('default')
        }
      } catch (e) {
        // 如果读取缓存失败，同样使用静态文案
        this.greetingText = getGreeting('default')
      }

      // 后台预取下一条问候语（供下次使用）
      this.fetchAndCacheNewGreeting()
    },

    /**
     * @description 后台预取新的问候语并存入缓存
     * 调用 sendMessage API 获取 AI 生成的问候语
     */
    fetchAndCacheNewGreeting() {
      // 延迟执行，不阻塞 UI
      setTimeout(async () => {
        // 检查页面是否已卸载
        if (this._isUnloaded) {
          return
        }

        // 优先使用固定角色的 conversationId，否则从缓存读取
        let conversationId: number | null = this.conversationId

        if (!conversationId) {
          try {
            conversationId = wx.getStorageSync(CONVERSATION_CACHE_KEY)
          } catch (e) {
            // 忽略错误
          }
        }

        // 如果没有 conversationId，降级使用静态文案
        if (!conversationId) {
          const newGreeting = getGreeting('default')
          this.saveGreetingToCache(newGreeting)
          return
        }

        // 调用 API 获取问候语
        try {
          const response = await conversationApi.sendMessage(conversationId, GREETING_COMMAND)

          // 再次检查页面状态
          if (this._isUnloaded) return

          const newGreeting = response.assistantMessage.content

          if (newGreeting) {
            this.saveGreetingToCache(newGreeting)
          }
        } catch (error: any) {
          if (this._isUnloaded) return

          // API 调用失败，降级使用静态文案
          const fallbackGreeting = getGreeting('default')
          this.saveGreetingToCache(fallbackGreeting)
        }
      }, 1000) // 延迟1秒执行
    },

    /**
     * @description 将问候语保存到缓存
     */
    saveGreetingToCache(text: string) {
      // 页面已卸载时不执行
      if (this._isUnloaded) return

      const newCache = {
        text,
        timestamp: Date.now(),
        used: false // 新缓存的问候语未使用
      }

      wx.setStorage({
        key: GREETING_CACHE_KEY,
        data: newCache
      })
    },

    navigateToChat() {
      // 跳转到角色卡片选择页面
      // 优先使用固定角色的 conversationId，否则使用最后一次对话的 conversationId
      let conversationId: number | null = this.conversationId

      if (!conversationId) {
        try {
          conversationId = wx.getStorageSync(CONVERSATION_CACHE_KEY)
        } catch (e) {
          // 忽略错误
        }
      }

      // 构建 URL 参数
      let url = '/pages/character-select'
      const params: string[] = []

      if (this.characterId) {
        params.push(`characterId=${this.characterId}`)
      }

      if (conversationId) {
        params.push(`conversationId=${conversationId}`)
      }

      if (params.length > 0) {
        url += '?' + params.join('&')
      }

      wx.navigateTo({ url })
    },
    navigateToCharacterSelect() {
      wx.navigateTo({
        url: '/pages/character-select'
      })
    },
    navigateToCreateCharacters() {
      wx.navigateTo({
        url: '/pages/create-character'
      })
    },
    navigateToConversations() {
      wx.navigateTo({
        url: '/pages/conversations'
      })
    },

    /**
     * @description 更新背景图片
     */
    updateBackground(chatBackgroundUrl?: string | null) {
      if (chatBackgroundUrl) {
        this.backgroundStyle = `background-image: url(${chatBackgroundUrl}); background-size: cover; background-position: center; background-repeat: no-repeat;`
      } else {
        this.backgroundStyle = ''
      }
    }
  }
})
</script>

<style lang="stylus">
.container
  width 100vw
  height 100vh
  background-size cover
  background-position center
  background-repeat no-repeat
  display flex
  flex-direction column
  justify-content flex-end
  align-items center
  position relative
  box-sizing border-box
  padding-bottom 80rpx // Reverted padding

  &::before
    content ''
    position absolute
    top 0
    left 0
    right 0
    bottom 0
    background rgba(0, 0, 0, 0.4)
    z-index 1

.content-wrapper
  position relative
  z-index 2
  width 100%
  display flex
  flex-direction column
  align-items flex-start // Changed to left-align card
  text-align center

.text-card
  position relative
  width 70%
  background rgba(255, 255, 255, 0.1) // Lowered transparency further
  border 1px solid rgba(255, 255, 255, 0.1)
  border-top none // Remove top border for fusion effect
  border-top-left-radius 0 // Sharp corner for fusion
  border-radius 0 24rpx 24rpx 24rpx
  padding 20rpx 40rpx
  margin-top 50rpx // Add space for the tab
  margin-bottom 120rpx
  margin-left 40rpx
  backdrop-filter blur(10px)
  -webkit-backdrop-filter blur(10px)
  box-shadow 0 8px 32px 0 rgba(0, 0, 0, 0.1)

.card-corner-tab
  position absolute
  top -50rpx // Positioned exactly on top of the card
  left 0
  color #fff
  font-size 32rpx
  font-weight bold

.card-text
  display block
  font-size 32rpx
  font-weight 400
  color #fff
  text-align left
  line-height 1.6
  text-shadow 0 1px 2px rgba(0, 0, 0, 0.2)

.button-group
  display flex
  flex-direction row
  align-items center
  justify-content center
  width 100%

.btn
  border-radius 50%
  font-weight bold
  color #fff
  display flex
  align-items center
  justify-content center
  text-align center
  border none
  box-shadow 0 4px 10px rgba(0, 0, 0, 0.3)
  transition all 0.2s ease-in-out
  -webkit-tap-highlight-color transparent // 移除移动端点击时的高亮效果
  padding 0 // 重置内边距

  &:active
    transform translateY(2px)
    opacity 0.9

.main-button
  background linear-gradient(135deg, #6a82fb, #fc5c7d)
  width 200rpx
  height 200rpx
  font-size 40rpx
  margin 0 40rpx

.secondary-button
  background rgba(255, 255, 255, 0.2)
  border 1px solid rgba(255, 255, 255, 0.3)
  width 140rpx
  height 140rpx
  font-size 30rpx

// Styles for new side navigation
.side-nav
  position absolute
  top 200rpx // Moved down again
  right 30rpx
  display flex
  flex-direction column
  z-index 10
  align-items flex-end

.side-nav-item
  border-radius 100rpx // Pill shape
  background rgba(255, 255, 255, 0.2)
  border 1px solid rgba(255, 255, 255, 0.3)
  display flex
  flex-direction row
  justify-content center
  align-items center
  margin-bottom 20rpx
  transition background 0.2s
  padding 12rpx 32rpx
  
  &:active
    background rgba(255, 255, 255, 0.3)

.side-nav-text
  display block
  color #fff
  font-size 30rpx
  font-weight 500

</style>

<script type="application/json">
  {
    "navigationBarTitleText": "AI 陪伴",
    "navigationStyle": "custom",
    "usingComponents": {}
  }
</script>
