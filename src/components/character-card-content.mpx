<template>
  <!-- å†…å®¹å¡ç‰‡ -->
  <view class="content-card">
    <!-- åˆå§‹çŠ¶æ€ï¼šæ˜¾ç¤ºè§’è‰²ä»‹ç»å’Œé—®å€™è¯­ -->
    <view wx:if="{{!hasStartedChat}}">
      <!-- è§’è‰²ä»‹ç»ï¼ˆä»…é¦–æ¬¡èŠå¤©æ˜¾ç¤ºï¼‰ -->
      <view class="intro-section" wx:if="{{!character.hasChatHistory && character.description}}">
        <text class="intro-label">ä»‹ç»ï¼š</text>
        <text class="intro-text">{{character.description}}</text>
      </view>

      <!-- é—®å€™è¯­æ¶ˆæ¯ -->
      <view class="greeting-message">
        <text class="message-text">{{character.greetingMessage || 'ä½ å¥½~'}}</text>
      </view>
    </view>

    <!-- èŠå¤©çŠ¶æ€ï¼šé»˜è®¤ä»…å±•ç¤ºæœ€åä¸€æ¡ AI å›å¤ -->
    <view wx:else class="chat-state">
      <scroll-view
        scroll-y
        class="message-list {{!historyReady ? 'is-preparing' : ''}}"
        scroll-top="{{scrollTop}}"
        scroll-into-view="{{scrollIntoView}}"
        scroll-with-animation="{{scrollWithAnimation}}"
        show-scrollbar="{{false}}"
        bindscroll="handleScroll"
      >
        <view wx:if="{{loading}}" class="loading">
          <text>åŠ è½½ä¸­...</text>
        </view>

        <view wx:else class="message-list-inner {{!showHistory ? 'preview-mode' : ''}}">
          <view wx:if="{{!loading && messages.length === 0}}" class="empty-preview">
            <text>æš‚æ— å†å²æ¶ˆæ¯</text>
          </view>
          <view wx:if="{{showHistory && hasMoreHistory}}" class="load-more" bindtap="handleLoadMoreHistory">
            <text>{{isLoadingHistory ? 'åŠ è½½ä¸­...' : 'æŸ¥çœ‹æ›´æ—©æ¶ˆæ¯'}}</text>
          </view>
          <message-bubble
            wx:for="{{messages}}"
            wx:key="id"
            id="msg-{{item.id}}"
            data-msg-id="{{item.id}}"
            class="message-item"
            index="{{index}}"
            message="{{item}}"
            bindmessageLongPress="handleMessageLongPress"
            bindmessageRollback="handleMessageRollbackTap"
            bindmessageRegenerate="handleMessageRegenerateTap"
          />
        </view>

        <!-- æ»šåŠ¨é”šç‚¹ -->
        <view id="scroll-bottom" class="scroll-anchor"></view>
      </scroll-view>
    </view>

    <!-- è§’è‰²ä¿¡æ¯å’Œå·¥å…·æ  -->
    <view class="info-toolbar">
      <!-- å·¦ä¾§ï¼šè§’è‰²å’Œä½œè€…ä¿¡æ¯ -->
      <view class="character-meta">
        <text class="meta-name">{{character.name}}</text>
        <text class="meta-author">{{character.isOfficial ? 'å®˜æ–¹' : 'ç”¨æˆ·åˆ›å»º'}}</text>
      </view>

      <!-- å³ä¾§ï¼šå·¥å…·æŒ‰é’® -->
      <view class="action-tools">
        <!-- æ”¶è— -->
        <view
          class="tool-item favorite-tool {{character.isFavorite ? 'active' : ''}}"
          bindtap="handleToggleFavorite"
        >
          <text class="tool-icon">{{character.isFavorite ? 'â¤ï¸' : 'ğŸ¤'}}</text>
        </view>

        <!-- å›ºå®šåˆ°é¦–é¡µ -->
        <view
          class="tool-item pin-tool {{isPinned ? 'active' : ''}}"
          bindtap="handlePinToHome"
        >
          <text class="tool-icon">{{isPinned ? 'â˜…' : 'â˜†'}}</text>
        </view>
        <view
          class="tool-item history-tool {{showHistory ? 'active' : ''}}"
          bindtap="toggleHistory"
        >
          <text class="tool-icon">ğŸ•˜</text>
        </view>
      </view>
    </view>

    <!-- è¾“å…¥æ¡† -->
    <view class="input-section">
      <input
        class="chat-input"
        type="text"
        placeholder="è¾“å…¥æ¶ˆæ¯å¼€å§‹èŠå¤©..."
        value="{{inputText}}"
        bindinput="handleInput"
        bindconfirm="handleSend"
        confirm-type="send"
        disabled="{{sending}}"
      />
      <button
        class="send-btn {{inputText ? 'active' : ''}}"
        bindtap="handleSend"
        disabled="{{sending || !inputText}}"
      >
        {{sending ? 'å‘é€ä¸­' : 'å‘é€'}}
      </button>
    </view>
  </view>

</template>

<script lang="ts">
import { createComponent } from '@mpxjs/core'
import { characterApi, conversationApi } from '../common/api'
import type { Character, Message, CreateConversationResponse, ConversationMessagesResponse, SendMessageResponse } from '../common/types'

type UIMessage = Message & { isLoading?: boolean }

const GREETING_CACHE_KEY = 'greeting_cache'
const CONVERSATION_CACHE_KEY = 'last_conversation_id'
const HOME_CHARACTER_CACHE_KEY = 'home_character'
const LAST_CONVERSATION_CHARACTER_KEY = 'last_conversation_character'
const MESSAGE_CACHE_PREFIX = 'conversation_messages_'
const HISTORY_PAGE_SIZE = 10

// æ¯ N æ¡æ¶ˆæ¯è§¦å‘ä¸€æ¬¡æ‘˜è¦æ›´æ–°ï¼ˆ20æ¡ = 10è½®å¯¹è¯ï¼‰
const MEMORY_UPDATE_MESSAGE_INTERVAL = 20

createComponent({
  properties: {
    // è§’è‰²æ•°æ®
    character: {
      type: Object as () => Character,
      value: null
    } as any,
    // å¯¹è¯IDï¼ˆå¦‚æœæ˜¯ä»å†å²è¿›å…¥ï¼‰
    initialConversationId: {
      type: Number,
      value: 0
    },
    // åˆå§‹æ¶ˆæ¯ï¼ˆå¦‚æœéœ€è¦è‡ªåŠ¨å‘é€ï¼‰
    initialMessage: {
      type: String,
      value: ''
    }
  },

  data: {
    conversationId: 0,
    messages: [] as UIMessage[],
    inputText: '',
    loading: false,
    sending: false,
    isPinned: false,
    hasStartedChat: false, // æ˜¯å¦å·²å¼€å§‹èŠå¤©
    showHistory: false,
    scrollWithAnimation: true,
    scrollTop: 0,
    historyReady: true,
    historyPage: 1,
    pageSize: HISTORY_PAGE_SIZE,
    hasMoreHistory: false,
    isLoadingHistory: false,
    currentScrollTop: 0,
    scrollIntoView: ''
  },

  lifetimes: {
    attached() {
      this.init()
    },

    detached() {
      // ç»„ä»¶å¸è½½æ—¶ï¼Œæ¸…é™¤é—®å€™è¯­ç¼“å­˜
      try {
        wx.removeStorageSync(GREETING_CACHE_KEY)
      } catch (e) {
        // å¿½ç•¥é”™è¯¯
      }

      // ç¼“å­˜å½“å‰ conversationId
      if (this.conversationId) {
        try {
          wx.setStorageSync(CONVERSATION_CACHE_KEY, this.conversationId)
          if (this.character) {
            wx.setStorageSync(LAST_CONVERSATION_CHARACTER_KEY, {
              conversationId: this.conversationId,
              character: { ...this.character },
              timestamp: Date.now()
            })
          }
        } catch (e) {
          // å¿½ç•¥é”™è¯¯
        }

        // è§¦å‘è®°å¿†æ‘˜è¦æ›´æ–°ï¼ˆå¼‚æ­¥ï¼Œä¸é˜»å¡é¡µé¢å¸è½½ï¼‰
        this.triggerMemoryUpdate()
      }
    }
  },

  methods: {
    // åˆå§‹åŒ–
    async init() {
      let conversationId = this.initialConversationId

      // å¦‚æœæ²¡æœ‰ä¼ å…¥ conversationIdï¼Œå°è¯•ä»ç¼“å­˜è·å–
      if (!conversationId && this.character?.id) {
        try {
          const cached = wx.getStorageSync(HOME_CHARACTER_CACHE_KEY)
          // å¦‚æœç¼“å­˜çš„è§’è‰²ä¸å½“å‰è§’è‰²åŒ¹é…ï¼Œä½¿ç”¨ç¼“å­˜çš„ conversationId
          if (cached && cached.characterId === this.character.id && cached.conversationId) {
            conversationId = cached.conversationId
          }
        } catch (e) {
          // å¿½ç•¥é”™è¯¯
        }
      }

      if (conversationId) {
        // å¦‚æœæœ‰ conversationIdï¼ŒåŠ è½½å·²æœ‰å¯¹è¯
        this.conversationId = conversationId
        await this.loadExistingConversation()

        // å¦‚æœæœ‰åˆå§‹æ¶ˆæ¯ï¼Œåœ¨åŠ è½½å®Œæˆåè‡ªåŠ¨å‘é€
        if (this.initialMessage) {
          setTimeout(() => {
            this.inputText = this.initialMessage
            this.handleSend()
          }, 500)
        }
      } else if (this.character?.id) {
        // å¦åˆ™åˆ›å»ºæ–°å¯¹è¯
        await this.createNewConversation()
      }

      this.checkIfPinned()
    },

    // åˆ›å»ºæ–°å¯¹è¯
    async createNewConversation() {
      try {
        this.loading = true

        // åˆ›å»ºå¯¹è¯ï¼ˆåç«¯ä¼šè¿”å›æ¶ˆæ¯åˆ—è¡¨ï¼‰
        const conversation: CreateConversationResponse = await conversationApi.createConversation(this.character.id)
        this.conversationId = conversation.id

        // ä½¿ç”¨åç«¯è¿”å›çš„æ¶ˆæ¯åˆ—è¡¨
        if (conversation.messages && conversation.messages.length > 0) {
          this.updateMessages(conversation.messages.map((msg: any) => ({
            id: msg.id,
            conversationId: this.conversationId,
            role: msg.role,
            content: msg.content,
            tokens: null,
            createdAt: msg.createdAt
          })))
        } else {
          this.updateMessages([])
        }
        this.historyPage = 1
        this.hasMoreHistory = false

        this.loading = false
        this.scrollToBottom()
      } catch (err: any) {
        wx.showToast({ title: err.message || 'åˆå§‹åŒ–å¤±è´¥', icon: 'none' })
        this.loading = false
      }
    },

    // åŠ è½½å·²æœ‰å¯¹è¯
    async loadExistingConversation() {
      try {
        this.loading = true

        const cachedMessages = this.getCachedMessages(this.conversationId)
        if (cachedMessages.length > 0) {
          this.updateMessages(cachedMessages)
        }

        // åŠ è½½å¯¹è¯ä¿¡æ¯å’Œæ¶ˆæ¯å†å²
        const response: ConversationMessagesResponse = await conversationApi.getConversationMessages(this.conversationId, 1, this.pageSize)

        // ä¿å­˜æ¶ˆæ¯åˆ—è¡¨
        this.updateMessages(response.messages || [])
        this.historyPage = 1
        this.hasMoreHistory = (response.messages || []).length === this.pageSize

        this.loading = false
        this.scrollToBottom()
      } catch (err: any) {
        wx.showToast({ title: err.message || 'åŠ è½½å¤±è´¥', icon: 'none' })
        this.loading = false
      }
    },

    // è¾“å…¥æ¡†å†…å®¹å˜åŒ–
    handleInput(e: any) {
      this.inputText = e.detail.value
    },

    handleMessageLongPress(e: any) {
      const detail = e?.detail || {}
      const message = detail.message as Message | undefined
      const index = typeof detail.index === 'number' ? detail.index : -1
      if (!message) return

      const canRegenerate = this.canRegenerate(message, index)
      const canRollback = this.canRollback(message, index)
      const itemList: string[] = []
      if (canRollback) itemList.push('å›æº¯')
      if (canRegenerate) itemList.push('é‡æ–°ç”Ÿæˆ')
      if (itemList.length === 0) return
      wx.showActionSheet({
        itemList,
        success: (res) => {
          const action = itemList[res.tapIndex]
          if (action === 'å›æº¯') {
            this.handleRollbackMessage(message, index)
            return
          }
          if (action === 'é‡æ–°ç”Ÿæˆ') {
            this.handleRegenerateMessage(message, index)
          }
        }
      })
    },

    handleMessageRollbackTap(e: any) {
      const detail = e?.detail || {}
      const message = detail.message as Message | undefined
      const index = typeof detail.index === 'number' ? detail.index : -1
      if (!message) return
      this.handleRollbackMessage(message, index)
    },

    handleMessageRegenerateTap(e: any) {
      const detail = e?.detail || {}
      const message = detail.message as Message | undefined
      const index = typeof detail.index === 'number' ? detail.index : -1
      if (!message) return
      if (!this.canRegenerate(message, index)) {
        wx.showToast({ title: 'ä»…æ”¯æŒé‡æ–°ç”Ÿæˆæœ€æ–°å›å¤', icon: 'none' })
        return
      }
      this.handleRegenerateMessage(message, index)
    },

    async handleRegenerateMessage(message: Message, index: number) {
      if (this.sending) return
      const content = this.getRegenerateContent(message, index)
      if (!content) {
        wx.showToast({ title: 'æœªæ‰¾åˆ°å¯é‡æ–°ç”Ÿæˆçš„ç”¨æˆ·æ¶ˆæ¯', icon: 'none' })
        return
      }
      const originalMessage = { ...this.messages[index] }
      const loadingMessages = [...this.messages]
      loadingMessages[index] = { ...originalMessage, isLoading: true }
      this.updateMessages(loadingMessages)
      this.sending = true
      try {
        const response: SendMessageResponse = await conversationApi.sendMessage(this.conversationId, content)
        const nextMessages = [...this.messages]
        nextMessages[index] = response.assistantMessage
        this.updateMessages(nextMessages)
        this.scrollToBottom()
      } catch (err: any) {
        const rollbackMessages = [...this.messages]
        rollbackMessages[index] = originalMessage
        this.updateMessages(rollbackMessages)
        wx.showToast({ title: err.message || 'é‡æ–°ç”Ÿæˆå¤±è´¥', icon: 'none' })
      } finally {
        this.sending = false
      }
    },

    canRegenerate(message: Message, index: number): boolean {
      if (message.role !== 'assistant') return false
      if (index !== this.messages.length - 1) return false
      return Boolean(this.getRegenerateContent(message, index))
    },

    canRollback(message: Message, index: number): boolean {
      if (index !== this.messages.length - 1) return true
      return message.role !== 'assistant'
    },

    getRegenerateContent(message: Message, index: number): string {
      if (message.role === 'user') {
        return message.content || ''
      }
      for (let i = index - 1; i >= 0; i -= 1) {
        const candidate = this.messages[i]
        if (candidate?.role === 'user') {
          return candidate.content || ''
        }
      }
      return ''
    },

    handleRollbackMessage(message: Message, index?: number) {
      if (!this.conversationId) {
        wx.showToast({ title: 'å¯¹è¯æœªåˆå§‹åŒ–', icon: 'none' })
        return
      }
      const localSnapshot = [...this.messages]
      const localIndex = typeof index === 'number'
        ? index
        : localSnapshot.findIndex((item) => item.id === message.id)
      if (localIndex < 0) return
      if (message.role === 'assistant') {
        if (!this.canRollback(message, localIndex)) {
          wx.showToast({ title: 'æ— æ³•å›æº¯æœ€æ–°å›å¤', icon: 'none' })
          return
        }
        const nextMessage = localSnapshot[localIndex + 1]
        const rollbackMessageId = nextMessage ? nextMessage.id : message.id
        wx.showModal({
          title: 'ç¡®è®¤å›æº¯',
          content: 'ç¡®è®¤å›æº¯åˆ°è¯¥å›å¤ï¼Ÿ',
          success: async (res) => {
            if (!res.confirm) return
            try {
              await conversationApi.rollbackConversation(this.conversationId, rollbackMessageId)
              const response: ConversationMessagesResponse = await conversationApi.getConversationMessages(this.conversationId, 1, this.pageSize)
              const nextMessages = response.messages || []
              const index = nextMessages.findIndex((item) => item.id === message.id)
              if (index >= 0) {
                this.updateMessages(nextMessages.slice(0, index + 1))
              } else {
                this.updateMessages(localIndex >= 0 ? localSnapshot.slice(0, localIndex + 1) : nextMessages)
              }
              this.hasMoreHistory = (response.messages || []).length === this.pageSize
              this.historyPage = 1
              this.scrollToBottom()
            } catch (err: any) {
              wx.showToast({ title: err.message || 'å›æº¯å¤±è´¥', icon: 'none' })
            }
          }
        })
        return
      }
      wx.showModal({
        title: 'ç¡®è®¤å›æº¯',
        content: 'ç¡®è®¤ä»è¯æ¡æ¶ˆæ¯å¼€å§‹å›æº¯ï¼Ÿ',
        success: async (res) => {
          if (!res.confirm) return
          try {
            await conversationApi.rollbackConversation(this.conversationId, message.id)
            const response: ConversationMessagesResponse = await conversationApi.getConversationMessages(this.conversationId, 1, this.pageSize)
            this.updateMessages(response.messages || [])
            this.hasMoreHistory = (response.messages || []).length === this.pageSize
            this.historyPage = 1
            this.inputText = message.content || ''
            this.scrollToBottom()
          } catch (err: any) {
            wx.showToast({ title: err.message || 'å›æº¯å¤±è´¥', icon: 'none' })
          }
        }
      })
    },

    // å‘é€æ¶ˆæ¯
    async handleSend() {
      const content = this.inputText.trim()
      if (!content || this.sending) return

      // å¦‚æœè¿˜æ²¡å¼€å§‹èŠå¤©ï¼Œå…ˆåˆ›å»ºå¯¹è¯
      if (!this.hasStartedChat) {
        await this.createNewConversation()
      }

      // 1. åˆ›å»ºå¹¶ç«‹å³æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
      const userMessage: Message = {
        id: Date.now(),
        conversationId: this.conversationId,
        role: 'user',
        content: content,
        tokens: null,
        createdAt: new Date().toISOString()
      }
      const pendingAssistantMessage: UIMessage = {
        id: Date.now() + 1,
        conversationId: this.conversationId,
        role: 'assistant',
        content: '',
        tokens: null,
        createdAt: new Date().toISOString(),
        isLoading: true
      }

      this.updateMessages([...this.messages, userMessage, pendingAssistantMessage])
      this.inputText = ''
      this.sending = true
      this.scrollToBottom()

      try {
        // 2. å‘é€æ¶ˆæ¯åˆ°åç«¯ï¼Œå¹¶æ¥æ”¶åŠ©æ‰‹æ¶ˆæ¯
        const response: SendMessageResponse = await conversationApi.sendMessage(this.conversationId, content)

        // 3. å°†åŠ©æ‰‹æ¶ˆæ¯æ·»åŠ åˆ°åˆ—è¡¨
        const messagesCopy = [...this.messages]
        const loadingIndex = messagesCopy.findIndex((item) => item.isLoading)
        if (loadingIndex >= 0) {
          messagesCopy[loadingIndex] = response.assistantMessage
        } else {
          messagesCopy.push(response.assistantMessage)
        }
        this.updateMessages(messagesCopy)

        this.scrollToBottom()

        // 4. æ£€æŸ¥æ˜¯å¦éœ€è¦è§¦å‘æ‘˜è¦æ›´æ–°ï¼ˆæ¯ 20 æ¡æ¶ˆæ¯è§¦å‘ä¸€æ¬¡ï¼‰
        if (this.messages.length > 0 && this.messages.length % MEMORY_UPDATE_MESSAGE_INTERVAL === 0) {
          console.log(`[Memory] æ¶ˆæ¯æ•°è¾¾åˆ° ${this.messages.length}ï¼Œè§¦å‘æ‘˜è¦æ›´æ–°`)
          this.triggerMemoryUpdate()
        }
      } catch (err: any) {
        wx.showToast({ title: err.message || 'å‘é€å¤±è´¥', icon: 'none' })
        this.updateMessages(this.messages.filter((item) => !item.isLoading))
      } finally {
        this.sending = false
      }
    },

    toggleHistory() {
      if (this.showHistory) {
        this.showHistory = false
        this.historyReady = true
        this.historyPage = 1
        if (this.messages.length > this.pageSize) {
          this.updateMessages(this.messages.slice(-this.pageSize))
        }
        return
      }
      this.historyReady = false
      this.showHistory = true
      this.scrollWithAnimation = false
      this.$nextTick(() => {
        this.scrollTop = this.scrollTop + 100000
        this.historyReady = true
      })
    },

    updateMessages(nextMessages: Message[]) {
      this.messages = nextMessages
      this.hasStartedChat = this.messages.length > 0
      this.cacheMessages()
      if (this.showHistory) {
        this.scrollToBottom()
      }
    },

    async handleLoadMoreHistory() {
      if (!this.hasMoreHistory || this.isLoadingHistory) return
      this.isLoadingHistory = true
      const nextPage = this.historyPage + 1
      try {
        const anchorId = await this.getFirstVisibleMessageId()
        const beforeMetrics = anchorId ? null : await this.getMessageListMetrics()
        const response: ConversationMessagesResponse = await conversationApi.getConversationMessages(this.conversationId, nextPage, this.pageSize)
        const nextMessages = response.messages || []
        if (nextMessages.length > 0) {
          this.scrollWithAnimation = false
          const payload: Record<string, any> = {
            messages: [...nextMessages, ...this.messages],
            historyPage: nextPage
          }
          if (anchorId) {
            payload.scrollIntoView = anchorId
          }
          this.batchUpdate(payload)
          if (anchorId) {
            await new Promise<void>((resolve) => this.$nextTick(resolve))
            this.batchUpdate({ scrollIntoView: '' })
          } else if (beforeMetrics) {
            await new Promise<void>((resolve) => this.$nextTick(resolve))
            const afterMetrics = await this.getMessageListMetrics()
            const deltaHeight = afterMetrics.scrollHeight - beforeMetrics.scrollHeight
            if (deltaHeight > 0) {
              this.scrollTop = beforeMetrics.scrollTop + deltaHeight
            }
          }
        }
        this.hasMoreHistory = nextMessages.length === this.pageSize
      } catch (err: any) {
        wx.showToast({ title: err.message || 'åŠ è½½å¤±è´¥', icon: 'none' })
      } finally {
        this.isLoadingHistory = false
      }
    },

    cacheMessages() {
      if (!this.conversationId) return
      try {
        const cacheKey = `${MESSAGE_CACHE_PREFIX}${this.conversationId}`
        const sliced = this.messages.slice(-HISTORY_PAGE_SIZE)
        wx.setStorageSync(cacheKey, sliced)
      } catch (e) {
        // å¿½ç•¥é”™è¯¯
      }
    },

    getCachedMessages(conversationId: number) {
      try {
        const cacheKey = `${MESSAGE_CACHE_PREFIX}${conversationId}`
        const cached = wx.getStorageSync(cacheKey)
        return Array.isArray(cached) ? cached : []
      } catch (e) {
        return []
      }
    },

    // æ»šåŠ¨åˆ°åº•éƒ¨
    scrollToBottom(animate = true) {
      this.$nextTick(() => {
        this.scrollWithAnimation = animate
        this.scrollTop = this.scrollTop + 100000
      })
    },

    handleScroll(e: any) {
      this.currentScrollTop = e.detail.scrollTop || 0
    },

    getMessageListMetrics() {
      return new Promise<{ scrollTop: number; scrollHeight: number }>((resolve) => {
        wx.createSelectorQuery()
          .in(this)
          .select('.message-list')
          .fields({ scrollOffset: true, scrollHeight: true } as any)
          .exec((res: any) => {
            const metrics = res && res[0] ? res[0] : {}
            resolve({
              scrollTop: typeof metrics.scrollTop === 'number' ? metrics.scrollTop : this.currentScrollTop,
              scrollHeight: typeof metrics.scrollHeight === 'number' ? metrics.scrollHeight : 0
            })
          })
      })
    },

    getFirstVisibleMessageId() {
      return new Promise<string>((resolve) => {
        wx.createSelectorQuery()
          .in(this)
          .select('.message-list')
          .boundingClientRect()
          .selectAll('.message-item')
          .fields({ rect: true, dataset: true })
          .exec((res: any) => {
            const listRect = res && res[0] ? res[0] : null
            const items = res && res[1] ? res[1] : []
            if (!listRect || !items.length) {
              resolve('')
              return
            }
            const threshold = listRect.top + 1
            const firstVisible = items.find((item: any) => item?.rect && item.rect.bottom > threshold)
            const msgId = firstVisible?.dataset?.msgId
            resolve(msgId ? `msg-${msgId}` : '')
          })
      })
    },

    batchUpdate(payload: Record<string, any>) {
      if (typeof (this as any).setData === 'function') {
        ;(this as any).setData(payload)
        return
      }
      Object.keys(payload).forEach((key) => {
        ;(this as any)[key] = payload[key]
      })
    },

    // æ£€æŸ¥æ˜¯å¦å·²å›ºå®šåˆ°é¦–é¡µï¼ˆä»æœ¬åœ°ç¼“å­˜åˆ¤æ–­ï¼Œç”¨äºå¿«é€Ÿæ˜¾ç¤ºï¼‰
    checkIfPinned() {
      try {
        const cached = wx.getStorageSync(HOME_CHARACTER_CACHE_KEY)
        this.isPinned = cached && cached.characterId === this.character?.id
      } catch (e) {
        this.isPinned = false
      }
    },

    // å›ºå®š/å–æ¶ˆå›ºå®šåˆ°é¦–é¡µ
    async handlePinToHome() {
      if (!this.character) {
        wx.showToast({ title: 'è§’è‰²ä¿¡æ¯åŠ è½½ä¸­...', icon: 'none' })
        return
      }

      try {
        // è°ƒç”¨åç«¯æ¥å£
        const result = await characterApi.togglePinToHome(this.character.id)
        this.isPinned = result.isPinnedToHome

        if (result.isPinnedToHome) {
          // å›ºå®šæˆåŠŸï¼Œæ›´æ–°æœ¬åœ°ç¼“å­˜
          const cacheData = {
            characterId: this.character.id,
            conversationId: this.conversationId || null,
            character: { ...this.character },
            timestamp: Date.now()
          }
          wx.setStorageSync(HOME_CHARACTER_CACHE_KEY, cacheData)
          wx.showToast({ title: 'å·²å›ºå®šåˆ°é¦–é¡µ', icon: 'success' })
        } else {
          // å–æ¶ˆå›ºå®šï¼Œæ¸…ç©ºæœ¬åœ°ç¼“å­˜
          wx.removeStorageSync(HOME_CHARACTER_CACHE_KEY)
          wx.showToast({ title: 'å·²å–æ¶ˆå›ºå®š', icon: 'success' })
        }

        // é€šçŸ¥çˆ¶ç»„ä»¶æ›´æ–°å…¶ä»–è§’è‰²å¡ç‰‡çš„å›ºå®šçŠ¶æ€
        this.triggerEvent('pinToHome', {
          character: this.character,
          isPinned: result.isPinnedToHome
        })
      } catch (e: any) {
        wx.showToast({ title: e.message || 'æ“ä½œå¤±è´¥', icon: 'none' })
      }
    },

    // ç‚¹èµ
    handleLike() {
      this.triggerEvent('like', { characterId: this.character.id })
    },

    // æŸ¥çœ‹å†å²æ¶ˆæ¯
    handleViewHistory() {
      this.triggerEvent('viewHistory', { characterId: this.character.id })
    },

    // åˆ‡æ¢æ”¶è—
    handleToggleFavorite() {
      this.triggerEvent('toggleFavorite', { characterId: this.character.id })
    },

    /**
     * è§¦å‘è®°å¿†æ‘˜è¦æ›´æ–°
     * å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡é¡µé¢æ“ä½œ
     */
    triggerMemoryUpdate() {
      if (!this.conversationId || !this.hasStartedChat) {
        return
      }

      // ä½¿ç”¨å¼‚æ­¥è°ƒç”¨ï¼Œä¸ç­‰å¾…ç»“æœ
      conversationApi.updateMemorySummary(this.conversationId)
        .then((result: { updated: boolean; message?: string; messagesProcessed?: number }) => {
          if (result.updated) {
            console.log(`[Memory] è®°å¿†æ‘˜è¦å·²æ›´æ–°ï¼Œå¤„ç†äº† ${result.messagesProcessed} æ¡æ¶ˆæ¯`)
          } else {
            console.log(`[Memory] ${result.message || 'æ— éœ€æ›´æ–°'}`)
          }
        })
        .catch((err: Error) => {
          // é™é»˜å¤±è´¥ï¼Œä¸å½±å“ç”¨æˆ·ä½“éªŒ
          console.warn('[Memory] æ‘˜è¦æ›´æ–°å¤±è´¥:', err.message)
        })
    }
  }
})
</script>

<style lang="stylus">
// å†…å®¹å¡ç‰‡
.content-card
  position relative
  z-index 3
  width 100vw
  padding 0rpx
  margin-bottom 40rpx

  // ä»‹ç»éƒ¨åˆ†
  .intro-section
    background rgba(255, 255, 255, 0.12)
    backdrop-filter blur(20rpx)
    border-radius 20rpx
    padding 24rpx 28rpx
    margin-bottom 20rpx
    border 1rpx solid rgba(255, 255, 255, 0.15)

    .intro-label
      font-size 26rpx
      color rgba(255, 255, 255, 0.7)
      font-weight 500
      margin-right 8rpx

    .intro-text
      font-size 26rpx
      color rgba(255, 255, 255, 0.95)
      line-height 1.6

  // é—®å€™è¯­æ¶ˆæ¯
  .greeting-message
    width 80%
    color rgba(255, 255, 255, 0.95)
    background-color rgba(255, 255, 255, 0.6)
    backdrop-filter blur(20rpx)
    border-radius 20rpx
    padding 28rpx
    margin-bottom 60rpx
    border 1rpx solid rgba(255, 255, 255, 0.15)

    .message-text
      font-size 30rpx
      color #333
      line-height 1.6
      display block

  .chat-state
    display flex
    flex-direction column

  .empty-preview
    padding 16rpx 32rpx
    color rgba(255, 255, 255, 0.7)
    font-size 24rpx

  // æ¶ˆæ¯åˆ—è¡¨
  .message-list
    height 65vh
    padding 32rpx 0
    margin-bottom 20rpx
    overflow-y auto

    &.is-preparing
      visibility hidden

    .loading
      text-align center
      padding 100rpx 0
      color rgba(255, 255, 255, 0.7)
      font-size 28rpx

    .scroll-anchor
      height 1rpx

  .message-list-inner
    min-height 100%
    display flex
    flex-direction column

    &.preview-mode
      justify-content flex-end
      
      > .message-item
        display none

      > .message-item:last-child
        display flex

    .load-more
      align-self center
      padding 12rpx 24rpx
      margin-bottom 12rpx
      border-radius 999rpx
      border 1rpx solid rgba(255, 255, 255, 0.2)
      color rgba(255, 255, 255, 0.85)
      font-size 24rpx

  // ä¿¡æ¯å’Œå·¥å…·æ 
  .info-toolbar
    display flex
    justify-content space-between
    align-items center
    margin-bottom 20rpx
    padding 0 32rpx

    .character-meta
      display flex
      flex-direction column
      gap 8rpx

      .meta-name
        font-size 32rpx
        font-weight 700
        color #fff
        text-shadow 0 2px 8px rgba(0,0,0,0.3)

      .meta-author
        font-size 24rpx
        color rgba(255, 255, 255, 0.7)

    .action-tools
      display flex
      align-items center
      gap 24rpx

      .tool-item
        display flex
        flex-direction column
        align-items center
        gap 2rpx
        transition all 0.2s

        &:active
          transform scale(0.95)

        .tool-icon
          font-size 32rpx
          color: #fff

        .tool-count
          font-size 20rpx
          color rgba(255, 255, 255, 0.8)

        &.favorite-tool.active
          background rgba(255, 100, 100, 0.25)
          border-color rgba(255, 100, 100, 0.4)

        &.pin-tool.active
          background rgba(255, 215, 0, 0.25)
          border-color rgba(255, 215, 0, 0.4)

        &.history-tool.active
          background rgba(255, 255, 255, 0.2)
          border-color rgba(255, 255, 255, 0.35)

  // è¾“å…¥æ¡†éƒ¨åˆ†
  .input-section
    display flex
    align-items center
    gap 16rpx
    background rgba(255, 255, 255, 0.12)
    backdrop-filter blur(20rpx)
    border-radius 16rpx
    padding 12rpx 16rpx
    margin: 0 32rpx
    border 1rpx solid rgba(255, 255, 255, 0.15)

    .chat-input
      flex 1
      height 64rpx
      background transparent
      border none
      font-size 28rpx
      color #fff
      padding 0 16rpx

      &::placeholder
        color rgba(255, 255, 255, 0.5)

    .send-btn
      height 64rpx
      padding 0 32rpx
      background rgba(255, 255, 255, 0.15)
      color rgba(255, 255, 255, 0.6)
      border-radius 32rpx
      font-size 28rpx
      border none
      transition all 0.2s

      &.active
        background linear-gradient(135deg, #667eea, #764ba2)
        color #fff

      &:active
        transform scale(0.98)

      &[disabled]
        opacity 0.5
</style>

<script type="application/json">
{
  "component": true,
  "usingComponents": {
    "message-bubble": "./message-bubble"
  }
}
</script>
