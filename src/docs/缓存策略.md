现在使用方案：
┌─────────────────────────────────────────────────────────────────────┐
  │                         用户进入首页                                  │
  └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │   检查缓存是否存在且未过期(3h)   │
                      │       且 used === false        │
                      └───────────────────────────────┘
                                      │
                   ┌──────────────────┴──────────────────┐
                   │ 是                                   │ 否
                   ▼                                      ▼
      ┌─────────────────────────┐          ┌─────────────────────────┐
      │  显示缓存的 AI 问候语     │          │  从静态库随机取一条显示   │
      │  标记 used = true        │          │                         │
      └─────────────────────────┘          └─────────────────────────┘
                   │                                      │
                   └──────────────────┬──────────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │      后台延迟1秒开始预取        │
                      └───────────────────────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │   检查是否有缓存的 conversationId │
                      └───────────────────────────────┘
                                      │
                   ┌──────────────────┴──────────────────┐
                   │ 有                                   │ 无
                   ▼                                      ▼
      ┌─────────────────────────┐          ┌─────────────────────────┐
      │ 调用 API [GET_GREETING]  │          │  缓存一条随机静态文案     │
      └─────────────────────────┘          │  used = false           │
                   │                        └─────────────────────────┘
                   │
          ┌────────┴────────┐
          │ 成功             │ 失败
          ▼                  ▼
  ┌──────────────────┐  ┌──────────────────┐
  │ 缓存 AI 问候语    │  │ 缓存随机静态文案   │
  │ used = false     │  │ used = false     │
  └──────────────────┘  └──────────────────┘


  ═══════════════════════════════════════════════════════════════════════

                          聊天页退出时

  ┌─────────────────────────────────────────────────────────────────────┐
  │                       用户退出聊天页                                  │
  └─────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │   清除问候语缓存 (greeting)     │
                      │   保存 conversationId 到缓存   │
                      └───────────────────────────────┘
                                      │
                                      ▼
                      ┌───────────────────────────────┐
                      │  下次进入首页时会预取新问候语   │
                      └───────────────────────────────┘

  效果示例：
  用户首次打开 App     → 静态随机 "今天心情怎么样？"
  进入聊天，聊完退出   → 清缓存，存 conversationId，后台预取 AI 问候语
  再次进入首页        → 显示 AI "下午好呀，刚才聊得开心~"（标记已用）
  再进入             → 静态随机 "想我了吗？"
  再进入             → 静态随机 "今天有什么新鲜事？"

  现在的结构：
  greetings.ts
  ├── commonGreetings     # 公共问候语（兜底）
  │   ├── morning
  │   ├── noon
  │   ├── afternoon
  │   ├── evening
  │   ├── night
  │   └── default
  │
  └── characterGreetings  # 角色专属问候语
      ├── 'qiyu'          # 祁煜 - 温柔治愈系
      │   ├── morning
      │   ├── ...
      │   └── default
      │
      └── 'xxx'           # 其他角色（待添加）

  优先级：
  角色专属(当前时间段) → 角色专属(default) → 公共(当前时间段) → 公共(default)


简单来说，任何可能让欢迎语“过时”或“不相关”的因素，都应该成为我们缓存策略的一部分。我们可以把这些因素分为几类：

  1. 时间因素 (最基础)

  这是最核心的上下文，我们可以把它分得更细：

   * 时间段 (Time of Day)：这是我们聊过的，比如：
       * 清晨 (5-8点)
       * 上午 (8-11点)
       * 中午 (11-13点)
       * 下午 (13-17点)
       * 傍晚 (17-22点)
       * 深夜 (22-5点)
   * 日期类型 (Day of the Week)：
       * 工作日 vs 周末 (“还在忙吗？” vs “周末去哪玩呀？”)
   * 特殊日期 (Special Dates)：
       * 节假日、纪念日等 (“新年快乐！”、“生日快乐！”)。
   * 上次访问间隔 (Recency)：
       * 首次使用：“初次见面，请多指教。”
       * 刚离开 (<1小时)：“我们又见面啦！”
       * 今天内再次打开：“今天过得怎么样？”
       * 隔天打开：“昨天我们聊到...，我还在想呢。”
       * 很久未见 (>1周)：“好久不见，有点想你。”

  2. 用户行为因素 (最关键)

  这是你最关心的，也是让AI“活起来”的关键。

   * 聊天活动：
       * 结束聊天后：这是最高优先级的失效触发器。只要完成了一次对话，缓存就应该被清除，以便下次生成与新聊天内容相关的问候。
       * 聊天情绪 (高级)：如果能判断上次聊天是开心还是难过，问候语可以体现关怀。“感觉你昨天心情很好，今天也要保持哦！”
   * 角色互动：
       * 切换了聊天角色：“怎么想起回来找我啦，是不是觉得我比TA有趣？”
       * 创造了新角色：“我看到你创造了一个新朋友，介意介绍给我认识吗？”

  3. 环境因素 (高级)

  这些属于锦上添花，会让AI的感知更立体。

   * 天气 (需调用天气API)：“下雨了，出门记得带伞哦。”
   * 地理位置 (需用户授权)：可以用来生成更本地化的问候，但涉及隐私，需要谨慎使用。

  ---

  总结：我们的缓存策略

  结合以上因素，我们可以设计一个优先级明确的缓存策略：

   1. 最高优先级：主动失效
       * 用户结束聊天后，必须清除缓存。
       * 用户切换/创建/删除角色后，应该清除缓存。

   2. 次级优先级：上下文变化失效
       * 每次打开App时，检查当前时间段、日期类型是否和缓存中的记录一致，不一致则缓存失效。

   3. 最低优先级：时间戳失效
       * 作为一个兜底策略，如果用户长时间没有任何行为，缓存也应该在一定时间后（比如6小时）自动过期。

  我们可以从最核心的因素开始实现：时间和上次聊天。先把这个基础打好，未来可以逐步增加其他因素，让AI伙伴越来越懂你。


  我的建议：让缓存成为“同源”的桥梁

  我们的逻辑可以这样升级：

   1. 首页 (`index.mpx`): 它的职责不变，依然是按我们设计的策略（缓存优先、后台预取）来管理和显示问候语。

   2. 聊天页 (`chat.mpx`): 当它被加载，并且是创建一个新聊天时（而不是加载一个已有对话），它的初始消息来源改变：
       * 优先从我们约定的缓存 greeting_cache 中读取问候语，作为AI发出的第一条消息。
       * 如果缓存为空（比如用户是第一次打开，或者刚聊完天缓存被清空了），再降级使用角色自己预设的默认欢迎语 character.greetingMessage。

  这样做的好处：

   * 体验无缝：用户在首页看到“今天天气真好，要不要出去走走？”，点击聊天后，聊天窗口里AI的第一句话就是“今天天气真好，要不要出去走走？”，体验非常连贯。
   * 逻辑复用：我们完全复用了已有的缓存逻辑，不需要增加新的接口或复杂的状态管理。
   * 行为统一：无论是首页还是聊天页，获取“动态”问候语的来源都是唯一的，即 greeting_cache。

  这个方案既解决了数据同步问题，又避免了你的“分离感”的担忧。